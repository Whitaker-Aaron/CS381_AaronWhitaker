#include <iostream>

#include "raylib-cpp.hpp"
#include "rlgl.h"

struct Skybox {
        raylib::Texture texture;
        raylib::Shader shader;
        raylib::Model cube;

        Skybox(): shader(0) {}

        void Init(){
            auto gen = raylib::Mesh::Cube(1,1,1);
            cube = ((raylib::Mesh*)(&gen))->LoadModelFrom();
            shader = raylib::Shader::LoadFromMemory(R"C++(#version 330

// Input vertex attributes
in vec3 vertexPosition;

// Input uniform values
uniform mat4 matProjection;
uniform mat4 matView;

// Output vertex attributes (to fragment shader)
out vec3 fragPosition;

void main()
{
    // Calculate fragment position based on model transformations
    fragPosition = vertexPosition;

    // Remove translation from the view matrix
    mat4 rotView = mat4(mat3(matView));
    vec4 clipPos = matProjection*rotView*vec4(vertexPosition, 1.0);

    // Calculate final vertex position
    gl_Position = clipPos;
}
)C++", R"C++(#version 330

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;

// Input uniform values
uniform samplerCube environmentMap;
uniform bool vflipped;
uniform bool doGamma;

// Output fragment color
out vec4 finalColor;

void main()
{
    // Fetch color from texture map
    vec3 color = vec3(0.0);

    if (vflipped) color = texture(environmentMap, vec3(fragPosition.x, -fragPosition.y, fragPosition.z)).rgb;
    else color = texture(environmentMap, fragPosition).rgb;

    if (doGamma)// Apply gamma correction
    {
        color = color/(color + vec3(1.0));
        color = pow(color, vec3(1.0/2.2));
    }

    // Calculate final fragment color
    finalColor = vec4(color, 1.0);
})C++"
);
            cube.materials[0].shader = shader;
            shader.SetValue("environmentMap", (int)MATERIAL_MAP_CUBEMAP, SHADER_UNIFORM_INT);
        }
    

 void Load(std::string filename){
    shader.SetValue("doGamma", 0, SHADER_UNIFORM_INT);
    shader.SetValue("vflipped", 0, SHADER_UNIFORM_INT);

    raylib::Image img(filename);

    texture.Load(img, CUBEMAP_LAYOUT_AUTO_DETECT);
    texture.SetFilter(TEXTURE_FILTER_BILINEAR);

    cube.materials[0].maps[MATERIAL_MAP_CUBEMAP].texture = texture;
 }


 void Draw(){
    rlDisableBackfaceCulling();
    rlDisableDepthMask();
    cube.Draw({});
    rlEnableBackfaceCulling();
    rlEnableDepthMask();
 }
};

int main(){
    raylib::Window window(500, 500, "CS381 - Assignment 0");

 



    raylib::Model bad("bad.obj");

    raylib::Camera camera(
        raylib::Vector3(0, 120, -500),
        raylib::Vector3(0, 0, 300),
        raylib::Vector3::Up(),
        45,
        CAMERA_PERSPECTIVE
    );




    raylib::Text text;

    //Skybox skybox;
    //skybox.Load("../textures/skybox.png");

    raylib::Model defaultCube("bad.obj");


    bool flag = false, flag2 = false;
    float animate = 40;
    int windHeight = 0, windWidth = 0;

    SetConfigFlags(FLAG_WINDOW_RESIZABLE);

    while(!window.ShouldClose()) { 
        window.BeginDrawing();
        {
            windWidth = window.GetWidth(); 
            windHeight = window.GetHeight();

           
            
             if(flag2 == false){
                window.ClearBackground(RAYWHITE);
                text.Draw("Black", (windWidth/2 - animate), (windHeight/2 - 20), 20, raylib::Color::Black());
                //flag = true;

              
            }

             else if(flag2 == true){
                window.ClearBackground(BLACK);
                text.Draw("White", (windWidth/2 - animate), (windHeight/2 - 20), 20, raylib::Color::White());
                //flag = false;

                  camera.BeginMode();
                {
                    defaultCube.Draw({50, 100, 150});
                }
                camera.EndMode();
            }

        if(flag2 == false){
            animate += 0.1;
            if(animate >= 140){
                flag2 = true;
            }
        }

        else if(flag2 == true){
            animate -= 0.1;
            //std::cout << animate << std::endl;
            if(animate <= 0.0f){
                //std::cout << "second condition triggered" << std::endl;
                flag2 = false;
            }
        }

         
            
        }
        window.EndDrawing();

    }
    
    return 0;
}

//Three types of architectures: 
//- State based: Setup state, changes on state update --> OpenGL, DirectX 
//- Command based: Record and replay --> Vulcan, Metal, WebGPU
//- Immediate Based: Ask -> immediate, everytime 











/*
#include <iostream> 
#include <concepts>

template<typename T>
concept is_integer = std::is_same_v<T, int>; 

// concept

template<std::floating_point T>
struct Lambda {
    int x = 0;
    void operator() (T t) const {
        std::cout << "Hello Lambda" << std::endl;
    }
};


int main(){

std::cout << "hello 384209374093247320" << std::endl;
Lambda l;
l();
int x = 5;

//Allen turing; lambda calculus -> alonzo church
//Lambda: Function without name
//Box called capter(?)
//Can capture variables from the outside
//Passing with ampersand allows us to edit the pointed to memory address

auto lambda = [l, x]() {
    std::cout << "Hello lambda 2 " << std::endl;
    l();
};
lambda();


return 0;

}*/